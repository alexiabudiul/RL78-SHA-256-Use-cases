// the implementation for the sha256 algorithm

#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

/* --- 1. INCLUDE SHA-256 CODE (VOLATILE variant) --- */
// ... [PASTE COMPLETE SHA-256 CODE HERE: init, update, final, compute] ...

/* ============================================================
 * MERKLE TREE CONFIGURATION
 * ============================================================ */

/* * Number of leaf nodes.
 * For a perfect binary tree, we use powers of 2.
 * 2^20 = 1,048,576 (Approx. 1 Million)
 * 2^21 = 2,097,152 (Approx. 2 Million)
 * 2^22 = 4,194,304 (Approx. 4 Million)
 */
#define TREE_HEIGHT      10          // Change this for 20, 21, 22
#define TOTAL_LEAVES     (1UL << TREE_HEIGHT)  // Calculate the real number: 2 ^ TREE_HEIGHT

#define HASH_SIZE        32
#define NODE_INPUT_SIZE  64          // 32 bytes Left + 32 bytes Right

/* * Stack for "pending" hashes at each tree level.
 * merkle_stack[0] holds the level 0 hash (leaf), etc.
 * On RL78, 22 * 32 bytes = 704 bytes. Fits comfortably in RAM.
 */
volatile uint8_t merkle_stack[TREE_HEIGHT + 1][HASH_SIZE];

/* Flags to indicate if a specific level is occupied */
volatile uint8_t level_occupied[TREE_HEIGHT + 1];

/* Temporary buffer for node concatenation (Left | Right) */
uint8_t combine_buffer[NODE_INPUT_SIZE];

/* Buffer for leaf data generation (dummy transaction of 64 bytes) */
uint8_t leaf_buffer[64];

/* ============================================================
 * MERKLE STREAMING LOGIC
 * ============================================================ */

void init_merkle_system(void) {
    uint8_t i;
    for(i = 0; i <= TREE_HEIGHT; i++) {
        level_occupied[i] = 0;
    }
}

/* Generates a unique "transaction" based on index */
void generate_leaf_data(uint32_t index) {
    uint8_t i;
    /* Simple pattern to ensure unique data */
    for(i = 0; i < 64; i++) {
        leaf_buffer[i] = (uint8_t)((index >> (i % 8)) ^ 0xAA);
    }
}

/* Core function: Adds a leaf and collapses the tree */
void add_leaf_to_tree(const uint8_t* leaf_hash) {
    uint8_t current_hash[HASH_SIZE];
    uint8_t level = 0;

    // 1. Copy leaf hash to current variable
    memcpy_u8(current_hash, leaf_hash, HASH_SIZE);

    // 2. Attempt to ascend the tree as much as possible
    while (level < TREE_HEIGHT) {
        
        if (level_occupied[level] == 0) {
            // Level is free. Park the hash here and wait for the pair.
            memcpy_u8((uint8_t*)merkle_stack[level], current_hash, HASH_SIZE);
            level_occupied[level] = 1;
            return; // Finished processing this leaf
        } 
        else {
            // Level is occupied! Found the pair (Left Child).
            // We are the Right Child.
            // Must combine: Hash(Left | Right)
            
            // a) Copy Left (from stack)
            memcpy_u8(combine_buffer, (uint8_t*)merkle_stack[level], HASH_SIZE);
            
            // b) Copy Right (current)
            memcpy_u8(combine_buffer + HASH_SIZE, current_hash, HASH_SIZE);
            
            // c) Calculate Parent Hash
            sha256_compute(combine_buffer, NODE_INPUT_SIZE, current_hash);
            
            // d) Free current level and ascend to next level
            level_occupied[level] = 0;
            level++;
        }
    }
    
    // If reached here, current_hash is ROOT (or partial root)
    // Store it at the last level for benchmarking
    memcpy_u8((uint8_t*)merkle_stack[TREE_HEIGHT], current_hash, HASH_SIZE);
}

/* Function to measure Overhead (only generation + empty logic) */
void run_overhead_benchmark(void) {
    uint32_t i;
    /* Only loop and generation */
    for(i = 0; i < TOTAL_LEAVES; i++) {
        generate_leaf_data(i);
        /* No hash, no tree logic */
        /* Read a byte to prevent loop elimination */
        g_sha_state[0] = leaf_buffer[0]; 
    }
}

int main(void) {
    run_overhead_benchmark();

    return 0;
}